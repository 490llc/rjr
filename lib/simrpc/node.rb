# simrpc node module
#
# Copyright (C) 2010 Mohammed Morsi <movitto@yahoo.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

module Simrpc

# Simrpc Method Message Controller, generates and handles method messages
class MethodMessageController
  public
    # initialize with a specified schema definition
    def initialize(schema_def)
      @schema_def = schema_def
    end

    # Generate new new method message, setting the message
    # target to the specified method name, and setting the fields
    # on the message to the method arguments
    def generate(method_name, args)
      mmethod = @schema_def.methods.find { |method| method.name == method_name }
      return nil if mmethod.nil?

      msg = Message::Message.new :header => {:id => IDBank.generate, :type => 'request', :target => mmethod.name }

      # if we have too few arguments, fill rest in w/ default values
      if mmethod.parameters.size > args.size
        mmethod.parameters[args.size...mmethod.parameters.size].each { |param| args << param.default }
      end

      msg.body.fields = (0...mmethod.parameters.size).collect { |i|
        Message::Field.new(:name => mmethod.parameters[i].name,
                           :value => mmethod.parameters[i].to_s(args[i], @schema_def))
      }

      return msg
    end

    # should be invoked when a message is received,
    # takes a message, converts it into a method call, and calls the corresponding
    # handler in the provided schema. Takes return arguments and sends back to caller
    def message_received(node, message, reply_to)
      message = Message::Message::from_s(message)
      mmethod = @schema_def.methods.find { |method| method.name == message.header.target }
      return nil if mmethod.nil?

      Logger.info "received method #{mmethod.name} message "

      # For request messages, dispatch to method handler
      if message.header.type == 'request'
        return nil if mmethod.handler.nil?

        # collect the method params
        params = (0...mmethod.parameters.size).collect { |i| mmethod.parameters[i].from_s(message.body.fields[i].value, @schema_def) }

        Logger.info "invoking #{mmethod.name} handler "

        # invoke method handler
        return_values = mmethod.handler.call(*params)  # FIXME handlers can't use 'return' as this will fall through here
                                                      # FIXME throw a catch block around this call to catch all handler exceptions
        return_values = [return_values] unless return_values.is_a? Array

        # consruct and send response message using return values
        response = Message::Message.new :header => {:id => message.header.id, :type => 'response', :target => mmethod.name }
        response.body.fields = (0...mmethod.return_values.size).collect { |i|
          field_def = mmethod.return_values[i]
          Message::Field.new :name => field_def.name, :value => field_def.to_s(return_values[i], @schema_def)
          # TODO if mmethod.return_values.size > return_values.size, fill in w/ default values
        }
        Logger.info "responding to #{reply_to}"
        node.send_message(reply_to, response)
        return message.header.id, params

      # For response values just return converted return values
      else
        results = (0...mmethod.return_values.size).collect { |i|
          mmethod.return_values[i].from_s(message.body.fields[i].value, @schema_def)
        }
        return message.header.id, results

      end
    end
end

# Simrpc Node represents ths main api which to communicate and send/listen for data.
class Node

   # Instantiate it w/ a specified id
   # or one will be autogenerated. Specify schema (or location) containing
   # data and methods which to invoke and/or handle. Optionally specify
   # a remote destination which to send new messages to. Automatically listens
   # for incoming messages.
   def initialize(args = {})
      @id = args[:id] if args.has_key? :id
      @schema = args[:schema]
      @schema_file = args[:schema_file]
      @destination = args[:destination]

      if !@schema.nil?
        @schema_def = Schema::Parser.parse(:schema => @schema)
      elsif !@schema_file.nil?
        @schema_def = Schema::Parser.parse(:file => @schema_file)
      end
      raise ArgumentError, "schema_def cannot be nil" if @schema_def.nil?
      @mmc = MethodMessageController.new(@schema_def)

      # hash of message id's -> response locks
      @message_locks = {}

      # FIXME currently not allowing for any other params to be passed into
      # QpidAdapter::Node such as broker ip or port, NEED TO FIX THIS
      @qpid_node = QpidAdapter::Node.new(:id => @id)
      @qpid_node.async_accept { |node, msg, reply_to|
          mid, results = @mmc.message_received(node, msg, reply_to)
          message_received(mid, results)
      }
   end

   def id
     return @id unless @id.nil?
     return @qpid_node.node_id
   end

   # implements, message_received callback to be notified when qpid receives a message
   def message_received(mid, results)
       @message_results = results unless results.nil?
       @message_locks[mid].signal unless mid.nil? || !@message_locks.has_key?(mid)
   end

   # Terminate node operations
   def terminate
     @qpid_node.terminate
   end

   # wait until the node is no longer accepting messages
   def join
       @qpid_node.join
   end

   # add a handler which to invoke when an schema method is invoked
   def handle_method(method, &handler)
      @schema_def.methods.each { |smethod|
         if smethod.name == method.to_s
             smethod.handler = handler
             break
         end
      }
   end

   # send method request to remote destination w/ the specified args
   def send_method(method_name, destination, *args)
      # generate and send new method message
      msg = @mmc.generate(method_name, args)
      @qpid_node.send_message(destination + "-queue", msg)

      # FIXME race condition if response is received b4 wait is invoked

      # block if we are expecting return values
      if @schema_def.methods.find{|m| m.name == method_name}.return_values.size != 0
        @message_locks[msg.header.id] =  Semaphore.new(1)
        @message_locks[msg.header.id].wait
        @message_locks[msg.header.id].wait # block until response received
        @message_locks.delete(msg.header.id)

        # return return values
        #@message_received.body.fields.collect { |f| f.value }
        return *@message_results
      end
      return nil
   end

   # can invoke schema methods directly on Node instances, this will catch
   # them and send them onto the destination
   def method_missing(method_id, *args)
     send_method(method_id.to_s, @destination, *args)
   end
end

end # module Simrpc
